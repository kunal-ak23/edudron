package com.datagami.edudron.content.service;

import com.datagami.edudron.common.TenantContext;
import com.datagami.edudron.common.UlidGenerator;
import com.datagami.edudron.content.domain.PsychometricTestResult;
import com.datagami.edudron.content.domain.PsychometricTestSession;
import com.datagami.edudron.content.repo.PsychometricTestResultRepository;
import com.datagami.edudron.content.repo.PsychometricTestSessionRepository;
import com.datagami.edudron.content.service.psychometric.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.OffsetDateTime;
import java.util.*;

/**
 * Hybrid Psychometric Test Service
 * Implements the new hybrid system with fixed core questions and adaptive modules
 */
@Service
@Transactional
public class HybridPsychometricTestService {
    
    private static final Logger logger = LoggerFactory.getLogger(HybridPsychometricTestService.class);
    
    private static final String DISCLAIMER_VERSION = "1.0";
    public static final String DISCLAIMER_TEXT = 
        "This assessment is generated by an AI system. No human counselor has reviewed individual results. " +
        "Results are suggestions only and non-binding. Students should discuss decisions with parents/guardians/counselors.";
    
    @Autowired
    private PsychometricTestSessionRepository sessionRepository;
    
    @Autowired
    private PsychometricTestResultRepository resultRepository;
    
    @Autowired
    private PsychometricScoringService scoringService;
    
    @Autowired
    private CareerMappingService careerMappingService;
    
    @Autowired
    private PsychometricTestAIService aiService;
    
    @Autowired
    private QuestionPersonalizationService personalizationService;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Value("${GATEWAY_URL:http://localhost:8080}")
    private String gatewayUrl;
    
    /**
     * Start a new hybrid psychometric test session
     */
    public PsychometricTestSession startTest(String studentId) {
        String clientIdStr = TenantContext.getClientId();
        if (clientIdStr == null) {
            throw new IllegalStateException("Tenant context is not set");
        }
        UUID clientId = UUID.fromString(clientIdStr);
        
        // Check for existing in-progress session
        Optional<PsychometricTestSession> existingSession = sessionRepository
            .findFirstByStudentIdAndClientIdAndStatusOrderByCreatedAtDesc(
                studentId, clientId, PsychometricTestSession.Status.IN_PROGRESS
            );
        
        if (existingSession.isPresent()) {
            logger.info("Found existing in-progress session: {}", existingSession.get().getId());
            return existingSession.get();
        }
        
        // Create new session
        PsychometricTestSession session = new PsychometricTestSession();
        session.setId(UlidGenerator.nextUlid());
        session.setClientId(clientId);
        session.setStudentId(studentId);
        session.setStatus(PsychometricTestSession.Status.IN_PROGRESS);
        session.setCurrentPhase(PsychometricTestSession.Phase.INITIAL_EXPLORATION);
        session.setStartedAt(OffsetDateTime.now());
        
        // Initialize session state
        SessionState state = new SessionState();
        state.setPhase("CORE");
        state.setCurrentQuestionIndex(0);
        
        // Get first core question
        Question firstQuestion = CoreQuestionBank.getQuestionByOrder(1);
        if (firstQuestion != null) {
            state.setCurrentQuestionId(firstQuestion.getId());
        }
        
        // Store session state in conversation history (repurposed for hybrid system)
        session.setConversationHistory(convertStateToJson(state));
        
        PsychometricTestSession saved = sessionRepository.save(session);
        logger.info("Started new hybrid psychometric test session: {} for student: {}", saved.getId(), studentId);
        return saved;
    }
    
    /**
     * Submit an answer and get the next question
     */
    public PsychometricTestSession submitAnswer(String sessionId, String answerValue) {
        String clientIdStr = TenantContext.getClientId();
        if (clientIdStr == null) {
            throw new IllegalStateException("Tenant context is not set");
        }
        UUID clientId = UUID.fromString(clientIdStr);
        
        PsychometricTestSession session = sessionRepository.findByIdAndClientId(sessionId, clientId)
            .orElseThrow(() -> new IllegalArgumentException("Test session not found: " + sessionId));
        
        if (session.getStatus() != PsychometricTestSession.Status.IN_PROGRESS) {
            throw new IllegalStateException("Test session is not in progress");
        }
        
        // Load session state
        SessionState state = convertJsonToState(session.getConversationHistory());
        
        // Check if test is already completed
        if ("COMPLETED".equals(state.getPhase())) {
            throw new IllegalStateException("Test is already completed. Please view your results.");
        }
        
        // Get current question
        Question currentQuestion;
        if ("CORE".equals(state.getPhase())) {
            currentQuestion = CoreQuestionBank.getQuestionById(state.getCurrentQuestionId());
        } else if (state.getPhase().startsWith("ADAPTIVE")) {
            currentQuestion = AdaptiveQuestionBank.getQuestionById(state.getCurrentQuestionId());
        } else {
            throw new IllegalStateException("Invalid phase: " + state.getPhase());
        }
        
        if (currentQuestion == null) {
            throw new IllegalStateException("Current question not found");
        }
        
        // Create final reference for use in lambdas
        final Question finalCurrentQuestion = currentQuestion;
        
        // Create answer
        Answer answer = new Answer(finalCurrentQuestion.getId(), answerValue);
        
        // Add answer to appropriate list
        if ("CORE".equals(state.getPhase())) {
            state.getCoreAnswers().add(answer);
            
            // Score the answer
            scoringService.scoreAnswer(answer, finalCurrentQuestion, state);
            
            // Move to next core question
            int nextIndex = state.getCurrentQuestionIndex() + 1;
            if (nextIndex < 18) {
                Question nextQuestion = CoreQuestionBank.getQuestionByOrder(nextIndex + 1);
                if (nextQuestion != null) {
                    state.setCurrentQuestionIndex(nextIndex);
                    state.setCurrentQuestionId(nextQuestion.getId());
                }
            } else {
                // Core questions complete - move to prime detection
                scoringService.scoreCoreAnswers(state, CoreQuestionBank.getCoreQuestions());
                scoringService.detectPrimeCandidates(state);
                
                // Select adaptive modules
                List<String> modules = scoringService.selectAdaptiveModules(state);
                state.setSelectedModules(modules);
                state.setCurrentModuleIndex(0);
                
                if (!modules.isEmpty()) {
                    state.setPhase("ADAPTIVE_MODULE_1");
                    // Use AI to select best first question
                    List<Question> available = AdaptiveQuestionBank.getAvailableQuestions(
                        modules.get(0), state.getAdaptiveAnswers());
                    Question firstAdaptive = personalizationService.selectBestNextQuestion(available, state);
                    if (firstAdaptive != null) {
                        state.setCurrentQuestionId(firstAdaptive.getId());
                        state.setCurrentQuestionIndex(0);
                    }
                } else {
                    // No modules selected - complete test
                    state.setPhase("COMPLETED");
                }
            }
        } else if (state.getPhase().startsWith("ADAPTIVE")) {
            state.getAdaptiveAnswers().add(answer);
            
            // Score the answer
            scoringService.scoreAnswer(answer, finalCurrentQuestion, state);
            
            // Determine which module we're in
            int moduleIndex = state.getCurrentModuleIndex() != null ? state.getCurrentModuleIndex() : 0;
            String currentModule = state.getSelectedModules().get(moduleIndex);
            
            // Check if we should continue or move to next module
            // Simple logic: continue until 6-10 questions or high confidence
            int questionsInModule = (int) state.getAdaptiveAnswers().stream()
                .filter(a -> finalCurrentQuestion.getModule().equals(currentModule))
                .count();
            
            if (questionsInModule >= 6 && state.getConfidenceScore() != null && state.getConfidenceScore() > 0.7) {
                // High confidence - can stop early
                if (moduleIndex < state.getSelectedModules().size() - 1) {
                    // Move to next module - use AI to select best first question
                    state.setCurrentModuleIndex(moduleIndex + 1);
                    state.setPhase("ADAPTIVE_MODULE_" + (moduleIndex + 2));
                    List<Question> nextModuleAvailable = AdaptiveQuestionBank.getAvailableQuestions(
                        state.getSelectedModules().get(moduleIndex + 1), state.getAdaptiveAnswers());
                    Question nextAdaptive = personalizationService.selectBestNextQuestion(
                        nextModuleAvailable, state);
                    if (nextAdaptive != null) {
                        state.setCurrentQuestionId(nextAdaptive.getId());
                        state.setCurrentQuestionIndex(0);
                    } else {
                        state.setPhase("COMPLETED");
                    }
                } else {
                    // All modules complete
                    state.setPhase("COMPLETED");
                }
            } else if (questionsInModule >= 10) {
                // Max questions reached for this module
                if (moduleIndex < state.getSelectedModules().size() - 1) {
                    // Move to next module - use AI to select best first question
                    state.setCurrentModuleIndex(moduleIndex + 1);
                    state.setPhase("ADAPTIVE_MODULE_" + (moduleIndex + 2));
                    List<Question> nextModuleAvailable = AdaptiveQuestionBank.getAvailableQuestions(
                        state.getSelectedModules().get(moduleIndex + 1), state.getAdaptiveAnswers());
                    Question nextAdaptive = personalizationService.selectBestNextQuestion(
                        nextModuleAvailable, state);
                    if (nextAdaptive != null) {
                        state.setCurrentQuestionId(nextAdaptive.getId());
                        state.setCurrentQuestionIndex(0);
                    } else {
                        state.setPhase("COMPLETED");
                    }
                } else {
                    // All modules complete
                    state.setPhase("COMPLETED");
                }
                } else {
                    // Continue with current module - use AI to select best next question
                    List<Question> available = AdaptiveQuestionBank.getAvailableQuestions(
                        currentModule, state.getAdaptiveAnswers());
                    Question nextAdaptive = personalizationService.selectBestNextQuestion(available, state);
                    if (nextAdaptive != null) {
                        state.setCurrentQuestionId(nextAdaptive.getId());
                        state.setCurrentQuestionIndex(state.getCurrentQuestionIndex() + 1);
                    } else {
                        // No more questions in this module
                        if (moduleIndex < state.getSelectedModules().size() - 1) {
                            state.setCurrentModuleIndex(moduleIndex + 1);
                            state.setPhase("ADAPTIVE_MODULE_" + (moduleIndex + 2));
                            List<Question> nextModuleAvailable = AdaptiveQuestionBank.getAvailableQuestions(
                                state.getSelectedModules().get(moduleIndex + 1), state.getAdaptiveAnswers());
                            Question nextModuleQuestion = personalizationService.selectBestNextQuestion(
                                nextModuleAvailable, state);
                            if (nextModuleQuestion != null) {
                                state.setCurrentQuestionId(nextModuleQuestion.getId());
                                state.setCurrentQuestionIndex(0);
                            } else {
                                state.setPhase("COMPLETED");
                            }
                        } else {
                            state.setPhase("COMPLETED");
                        }
                    }
                }
        }
        
        // Update session with new state
        session.setConversationHistory(convertStateToJson(state));
        
        return sessionRepository.save(session);
    }
    
    /**
     * Get current question for a session (with personalization)
     */
    public Question getCurrentQuestion(String sessionId) {
        PsychometricTestSession session = getTestStatus(sessionId);
        SessionState state = convertJsonToState(session.getConversationHistory());
        
        // If test is completed, return null
        if ("COMPLETED".equals(state.getPhase())) {
            return null;
        }
        
        if (state.getCurrentQuestionId() == null) {
            return null;
        }
        
        Question question = null;
        if ("CORE".equals(state.getPhase())) {
            question = CoreQuestionBank.getQuestionById(state.getCurrentQuestionId());
        } else if (state.getPhase().startsWith("ADAPTIVE")) {
            question = AdaptiveQuestionBank.getQuestionById(state.getCurrentQuestionId());
        }
        
        if (question == null) {
            return null;
        }
        
        // ALWAYS personalize the question text - make it conversational and engaging
        Question personalized = new Question();
        personalized.setId(question.getId());
        personalized.setType(question.getType());
        // For forced-choice, keep original options (they must match the question)
        personalized.setOptions(question.getOptions());
        personalized.setScoringTags(question.getScoringTags());
        personalized.setModule(question.getModule());
        personalized.setOrder(question.getOrder());
        
        try {
            StudentProfile profile = getStudentProfile(session.getStudentId());
            logger.info("Personalizing question {} for student grade {}", question.getId(), profile != null ? profile.getGrade() : "unknown");
            
            String personalizedText = personalizationService.personalizeQuestion(question, profile, state);
            if (personalizedText != null && !personalizedText.isEmpty() && !personalizedText.equals(question.getText())) {
                personalized.setText(personalizedText);
                logger.info("Successfully personalized question: '{}' -> '{}'", question.getText(), personalizedText);
                
                // For forced-choice questions, verify the personalized text aligns with options
                if (question.getType() == Question.QuestionType.FORCED_CHOICE) {
                }
                
                return personalized;
            } else {
                logger.warn("Personalization returned same or empty text, using fallback");
            }
        } catch (Exception e) {
            logger.error("AI personalization failed, using fallback: {}", e.getMessage(), e);
        }
        
        // Fallback: at least remove research words
        String fallback = personalizationService.removeResearchWords(question.getText());
        personalized.setText(fallback != null && !fallback.isEmpty() ? fallback : question.getText());
        logger.info("Using fallback personalization: '{}' -> '{}'", question.getText(), personalized.getText());
        return personalized;
    }
    
    /**
     * Get student profile from LMS (simplified - should integrate with student service)
     */
    private StudentProfile getStudentProfile(String studentId) {
        // TODO: Integrate with student service to get actual profile
        // For now, return a basic profile - in production, fetch from student service
        StudentProfile profile = new StudentProfile();
        profile.setGrade(10); // Default grade - should fetch from student service
        profile.setName("Student"); // Should fetch from student service
        // profile.setBoard(...); // Should fetch from student service
        // profile.setCourseHistory(...); // Should fetch from student service
        return profile;
    }
    
    /**
     * Complete the test and generate results
     */
    public PsychometricTestResult completeTest(String sessionId) {
        String clientIdStr = TenantContext.getClientId();
        if (clientIdStr == null) {
            throw new IllegalStateException("Tenant context is not set");
        }
        UUID clientId = UUID.fromString(clientIdStr);
        
        PsychometricTestSession session = sessionRepository.findByIdAndClientId(sessionId, clientId)
            .orElseThrow(() -> new IllegalArgumentException("Test session not found: " + sessionId));
        
        if (session.getStatus() != PsychometricTestSession.Status.IN_PROGRESS) {
            throw new IllegalStateException("Test session is not in progress");
        }
        
        // Load session state
        SessionState state = convertJsonToState(session.getConversationHistory());
        
        // Ensure all answers are scored
        if ("CORE".equals(state.getPhase()) || state.getPhase().startsWith("ADAPTIVE")) {
            scoringService.scoreCoreAnswers(state, CoreQuestionBank.getCoreQuestions());
            scoringService.detectPrimeCandidates(state);
        }
        
        // Determine streams
        Map<String, String> streams = scoringService.determineStreams(state);
        
        // Get top RIASEC themes
        List<RiasecTheme> topRiasecThemes = scoringService.getTopRiasecThemes(state);
        
        // Get career suggestions
        List<String> careerFields = careerMappingService.getSuggestedCareerFields(
            topRiasecThemes, streams.get("primary"), streams.get("secondary"));
        
        // Get course suggestions
        List<String> courseIds = careerMappingService.getSuggestedCourseIds(
            streams.get("primary"), topRiasecThemes, state.getIndicatorScores());
        
        // Generate AI reasoning
        String reasoning = generateReasoning(state, streams, topRiasecThemes, careerFields);
        
        // Normalize stream scores to 0-100 range
        Map<String, Double> normalizedStreamScores = normalizeScores(state.getStreamScores());
        
        // Create test result
        TestResult testResult = new TestResult();
        testResult.setPrimaryStream(streams.get("primary"));
        testResult.setSecondaryStream(streams.get("secondary"));
        testResult.setTopRiasecThemes(topRiasecThemes);
        testResult.setSuggestedCareerFields(careerFields);
        testResult.setSuggestedCourseIds(courseIds);
        testResult.setFinalRiasecScores(state.getRiasecScores());
        testResult.setFinalIndicatorScores(state.getIndicatorScores());
        testResult.setFinalStreamScores(normalizedStreamScores); // Use normalized scores
        testResult.setReasoning(reasoning);
        testResult.setDisclaimerVersion(DISCLAIMER_VERSION);
        
        // Save result entity
        PsychometricTestResult result = new PsychometricTestResult();
        result.setId(UlidGenerator.nextUlid());
        result.setClientId(clientId);
        result.setStudentId(session.getStudentId());
        result.setSessionId(sessionId);
        // Use normalized scores for storage
        result.setFieldScores(convertScoresToJson(normalizedStreamScores));
        result.setPrimaryField(streams.get("primary"));
        result.setSecondaryFields(convertListToJson(Arrays.asList(streams.get("secondary"))));
        result.setRecommendations(convertTestResultToJson(testResult));
        result.setTestSummary(reasoning);
        
        // Mark session as completed
        session.setStatus(PsychometricTestSession.Status.COMPLETED);
        session.setCurrentPhase(PsychometricTestSession.Phase.COMPLETED);
        session.setCompletedAt(OffsetDateTime.now());
        sessionRepository.save(session);
        
        PsychometricTestResult saved = resultRepository.save(result);
        logger.info("Completed hybrid psychometric test session: {} with result: {}", sessionId, saved.getId());
        return saved;
    }
    
    /**
     * Get session state (helper method for controller)
     */
    public SessionState getSessionState(String sessionId) {
        try {
            PsychometricTestSession session = getTestStatus(sessionId);
            return convertJsonToState(session.getConversationHistory());
        } catch (Exception e) {
            logger.error("Failed to get session state", e);
            return null;
        }
    }
    
    /**
     * Get test status
     */
    public PsychometricTestSession getTestStatus(String sessionId) {
        String clientIdStr = TenantContext.getClientId();
        if (clientIdStr == null) {
            throw new IllegalStateException("Tenant context is not set");
        }
        UUID clientId = UUID.fromString(clientIdStr);
        
        return sessionRepository.findByIdAndClientId(sessionId, clientId)
            .orElseThrow(() -> new IllegalArgumentException("Test session not found: " + sessionId));
    }
    
    /**
     * Get test result
     */
    public PsychometricTestResult getTestResult(String sessionId) {
        String clientIdStr = TenantContext.getClientId();
        if (clientIdStr == null) {
            throw new IllegalStateException("Tenant context is not set");
        }
        UUID clientId = UUID.fromString(clientIdStr);
        
        return resultRepository.findBySessionIdAndClientId(sessionId, clientId)
            .orElseThrow(() -> new IllegalArgumentException("Test result not found for session: " + sessionId));
    }
    
    /**
     * Get all results for a student
     */
    public List<PsychometricTestResult> getStudentResults(String studentId) {
        String clientIdStr = TenantContext.getClientId();
        if (clientIdStr == null) {
            throw new IllegalStateException("Tenant context is not set");
        }
        UUID clientId = UUID.fromString(clientIdStr);
        
        return resultRepository.findByStudentIdAndClientIdOrderByCreatedAtDesc(studentId, clientId);
    }
    
    // Helper methods
    
    /**
     * Normalize scores to 0-100 range
     * Uses min-max normalization: (score - min) / (max - min) * 100
     */
    private Map<String, Double> normalizeScores(Map<String, Double> scores) {
        if (scores == null || scores.isEmpty()) {
            return new HashMap<>();
        }
        
        // Find min and max values
        double min = scores.values().stream().mapToDouble(Double::doubleValue).min().orElse(0.0);
        double max = scores.values().stream().mapToDouble(Double::doubleValue).max().orElse(0.0);
        
        // If all scores are the same, return 50% for all
        if (max == min) {
            Map<String, Double> normalized = new HashMap<>();
            scores.keySet().forEach(key -> normalized.put(key, 50.0));
            return normalized;
        }
        
        // Normalize each score to 0-100 range
        Map<String, Double> normalized = new HashMap<>();
        for (Map.Entry<String, Double> entry : scores.entrySet()) {
            double normalizedValue = ((entry.getValue() - min) / (max - min)) * 100.0;
            normalized.put(entry.getKey(), Math.max(0.0, Math.min(100.0, normalizedValue))); // Clamp to 0-100
        }
        
        return normalized;
    }
    
    private String generateReasoning(SessionState state, Map<String, String> streams, 
                                     List<RiasecTheme> topRiasecThemes, List<String> careerFields) {
        // Use AI to generate reasoning based on scores
        try {
            String prompt = String.format(
                "Based on the psychometric test results:\n" +
                "Primary Stream: %s\n" +
                "Secondary Stream: %s\n" +
                "Top RIASEC Themes: %s\n" +
                "Stream Scores: %s\n" +
                "RIASEC Scores: %s\n\n" +
                "Generate a brief, student-friendly explanation (2-3 sentences) explaining why these suggestions " +
                "were made. Use phrases like 'Based on your responses', 'May suit you', 'Suggested'. " +
                "Do NOT use deterministic language like 'You should' or 'You must'.",
                streams.get("primary"),
                streams.get("secondary"),
                topRiasecThemes,
                state.getStreamScores(),
                state.getRiasecScores()
            );
            
            return aiService.generateReasoning(prompt);
        } catch (Exception e) {
            logger.error("Failed to generate reasoning", e);
            return "Based on your responses, we suggest exploring " + streams.get("primary") + 
                   " stream. This suggestion is based on your interests and responses to the assessment questions.";
        }
    }
    
    private JsonNode convertStateToJson(SessionState state) {
        try {
            ObjectNode json = objectMapper.createObjectNode();
            json.put("phase", state.getPhase());
            json.put("currentQuestionIndex", state.getCurrentQuestionIndex());
            json.put("currentQuestionId", state.getCurrentQuestionId());
            json.put("confidenceScore", state.getConfidenceScore() != null ? state.getConfidenceScore() : 0.0);
            json.put("currentModuleIndex", state.getCurrentModuleIndex());
            
            // Convert answers
            ArrayNode coreAnswers = objectMapper.createArrayNode();
            for (Answer answer : state.getCoreAnswers()) {
                ObjectNode answerNode = objectMapper.createObjectNode();
                answerNode.put("questionId", answer.getQuestionId());
                answerNode.put("value", answer.getValue());
                answerNode.put("timestamp", answer.getTimestamp());
                coreAnswers.add(answerNode);
            }
            json.set("coreAnswers", coreAnswers);
            
            ArrayNode adaptiveAnswers = objectMapper.createArrayNode();
            for (Answer answer : state.getAdaptiveAnswers()) {
                ObjectNode answerNode = objectMapper.createObjectNode();
                answerNode.put("questionId", answer.getQuestionId());
                answerNode.put("value", answer.getValue());
                answerNode.put("timestamp", answer.getTimestamp());
                adaptiveAnswers.add(answerNode);
            }
            json.set("adaptiveAnswers", adaptiveAnswers);
            
            // Convert scores
            ObjectNode riasecScores = objectMapper.createObjectNode();
            state.getRiasecScores().forEach(riasecScores::put);
            json.set("riasecScores", riasecScores);
            
            ObjectNode indicatorScores = objectMapper.createObjectNode();
            state.getIndicatorScores().forEach(indicatorScores::put);
            json.set("indicatorScores", indicatorScores);
            
            ObjectNode streamScores = objectMapper.createObjectNode();
            state.getStreamScores().forEach(streamScores::put);
            json.set("streamScores", streamScores);
            
            // Convert lists
            ArrayNode primeCandidates = objectMapper.createArrayNode();
            state.getPrimeCandidates().forEach(primeCandidates::add);
            json.set("primeCandidates", primeCandidates);
            
            ArrayNode selectedModules = objectMapper.createArrayNode();
            state.getSelectedModules().forEach(selectedModules::add);
            json.set("selectedModules", selectedModules);
            
            return json;
        } catch (Exception e) {
            logger.error("Failed to convert state to JSON", e);
            return objectMapper.createObjectNode();
        }
    }
    
    private SessionState convertJsonToState(JsonNode json) {
        SessionState state = new SessionState();
        
        if (json == null || !json.isObject()) {
            return state;
        }
        
        state.setPhase(json.has("phase") ? json.get("phase").asText() : "CORE");
        state.setCurrentQuestionIndex(json.has("currentQuestionIndex") ? json.get("currentQuestionIndex").asInt() : 0);
        state.setCurrentQuestionId(json.has("currentQuestionId") ? json.get("currentQuestionId").asText() : null);
        state.setConfidenceScore(json.has("confidenceScore") ? json.get("confidenceScore").asDouble() : null);
        state.setCurrentModuleIndex(json.has("currentModuleIndex") ? json.get("currentModuleIndex").asInt() : null);
        
        // Convert answers
        if (json.has("coreAnswers") && json.get("coreAnswers").isArray()) {
            for (JsonNode answerNode : json.get("coreAnswers")) {
                Answer answer = new Answer(
                    answerNode.get("questionId").asText(),
                    answerNode.get("value").asText()
                );
                if (answerNode.has("timestamp")) {
                    answer.setTimestamp(answerNode.get("timestamp").asLong());
                }
                state.getCoreAnswers().add(answer);
            }
        }
        
        if (json.has("adaptiveAnswers") && json.get("adaptiveAnswers").isArray()) {
            for (JsonNode answerNode : json.get("adaptiveAnswers")) {
                Answer answer = new Answer(
                    answerNode.get("questionId").asText(),
                    answerNode.get("value").asText()
                );
                if (answerNode.has("timestamp")) {
                    answer.setTimestamp(answerNode.get("timestamp").asLong());
                }
                state.getAdaptiveAnswers().add(answer);
            }
        }
        
        // Convert scores
        if (json.has("riasecScores") && json.get("riasecScores").isObject()) {
            json.get("riasecScores").fields().forEachRemaining(entry -> {
                state.getRiasecScores().put(entry.getKey(), entry.getValue().asDouble());
            });
        }
        
        if (json.has("indicatorScores") && json.get("indicatorScores").isObject()) {
            json.get("indicatorScores").fields().forEachRemaining(entry -> {
                state.getIndicatorScores().put(entry.getKey(), entry.getValue().asDouble());
            });
        }
        
        if (json.has("streamScores") && json.get("streamScores").isObject()) {
            json.get("streamScores").fields().forEachRemaining(entry -> {
                state.getStreamScores().put(entry.getKey(), entry.getValue().asDouble());
            });
        }
        
        // Convert lists
        if (json.has("primeCandidates") && json.get("primeCandidates").isArray()) {
            for (JsonNode candidate : json.get("primeCandidates")) {
                state.getPrimeCandidates().add(candidate.asText());
            }
        }
        
        if (json.has("selectedModules") && json.get("selectedModules").isArray()) {
            for (JsonNode module : json.get("selectedModules")) {
                state.getSelectedModules().add(module.asText());
            }
        }
        
        return state;
    }
    
    private JsonNode convertScoresToJson(Map<String, Double> scores) {
        ObjectNode json = objectMapper.createObjectNode();
        scores.forEach(json::put);
        return json;
    }
    
    private JsonNode convertListToJson(List<String> list) {
        ArrayNode json = objectMapper.createArrayNode();
        if (list != null) {
            list.forEach(json::add);
        }
        return json;
    }
    
    private JsonNode convertTestResultToJson(TestResult testResult) {
        try {
            ObjectNode json = objectMapper.createObjectNode();
            json.put("primaryStream", testResult.getPrimaryStream());
            if (testResult.getSecondaryStream() != null) {
                json.put("secondaryStream", testResult.getSecondaryStream());
            }
            
            ArrayNode careerFields = objectMapper.createArrayNode();
            testResult.getSuggestedCareerFields().forEach(careerFields::add);
            json.set("suggestedCareerFields", careerFields);
            
            ArrayNode courseIds = objectMapper.createArrayNode();
            testResult.getSuggestedCourseIds().forEach(courseIds::add);
            json.set("suggestedCourseIds", courseIds);
            
            ArrayNode riasecThemes = objectMapper.createArrayNode();
            for (RiasecTheme theme : testResult.getTopRiasecThemes()) {
                ObjectNode themeNode = objectMapper.createObjectNode();
                themeNode.put("code", theme.getCode());
                themeNode.put("name", theme.getName());
                themeNode.put("score", theme.getScore());
                themeNode.put("explanation", theme.getExplanation());
                riasecThemes.add(themeNode);
            }
            json.set("topRiasecThemes", riasecThemes);
            
            json.put("reasoning", testResult.getReasoning());
            json.put("disclaimerVersion", testResult.getDisclaimerVersion());
            
            return json;
        } catch (Exception e) {
            logger.error("Failed to convert test result to JSON", e);
            return objectMapper.createObjectNode();
        }
    }
}
